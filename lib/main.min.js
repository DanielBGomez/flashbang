(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

require("./objects");

require("./windows"); // Imports

/**
 * @typedef {Object} Overwolf
 * @property {WindowsAPI} windows
 */

/**
 * @type {Overwolf}
 */


var ow = typeof overwolf != "undefined" ? overwolf : {
  windows: {}
};
var _default = ow;
exports["default"] = _default;

},{"./objects":2,"./windows":3}],2:[function(require,module,exports){
/**
 * An object that Enable the manifest size and position settings (default is false).
 * 
 * The default behaviour of OW is to "remember" the last size and position of a window, before it closes. When useDefaultSizeAndLocation is set to true, the window will be created using the default (manifest) size and location, rather than the saved setting (if one exists).
 * 
 * If there is no "start_position" property (size and position) for a window in the manifest, it will default to 0,0.
 * 
 * @typedef {Object} DefaultSizeAndLocation
 * 
 * @property {bool} useDefaultSizeAndLocation
 */

/**
 * The current window object.
 * 
 * @typedef {Object} WindowInfo
 * 
 * @property {string} id
 * @property {string} name
 * @property {number} width
 * @property {number} height
 * @property {number} top
 * @property {number} left
 * @property {boolean} isVisible
 * @property {WindowStateEx} stateEx    Always use this param to get the state of the window
 * @property {string} monitorId         Return monitorId (If the Window is not opened already) - allowing one window (background) to know on which monitor another window exists.
 * @property {string} Parent            The parent window id
 * @property {string} state             Deprecated and kept only for backward compatibility
 */

/**
 * An object that allows to override the manifest.json requested window settings.
 * 
 * @typedef {Object} WindowProperties
 * 
 * @property {boolean} nativeWindow
 * @property {boolean} enablePopupBlocker
 */

/**
 * Container for the currrent window object.
 * 
 * @typedef {Object} WindowResult
 * 
 * @property {boolean} success
 * @property {WindowInfo} window
 */

/**
 * Possible windows states
 * 
 * @typedef {'closed'|'minimized'|'hidden'|'normal'|'maximized'} WindowStateEx
 */
"use strict";

},{}],3:[function(require,module,exports){
/**
 * Returns a window object of the index page.
 * 
 * This function allows you to get direct access to your main index page (which should be a controller/background page) and it’s HTML Window object (and thus any JS function or DOM element), which is also guaranteed to exist when calling this method from any other window (unlike the getOpenWindows()).
 * 
 * If you hold one global "manager" object in your background, then all other windows have a single object to interact with. This is why we recommend the getMainWindow() approach.
 * 
 * overwolf.windows.sendMessage performs object copying, so it might be a bit less efficient - depending on your use-case
 * 
 * Read more in the {@link https://overwolf.github.io/docs/topics/communicating-between-windows|"Communication between windows"} section.
 * 
 * @callback getMainWindow
 * @returns {Window} 
 */

/**
 * Calls the given callback function with the current window object as a parameter.
 * 
 * @callback getCurrentWindow
 * @param {CBWindowResult} callback A callback function which will be called with the current window object as a parameter
 * @returns {void}
 */

/**
 * Creates an instance of your window (the window’s name has to be declared in the manifest.json) or returns a window by the window name.
 * 
 * @callback obtainDeclaredWindow
 * @param {string} windowName           The name of the window that was declared in the data.windows section in the manifest
 * @param {CBWindowResult} callback     A callback function which will be called with the current window object as a parameter
 */

/**
 * Start dragging a window.
 * 
 * @callback dragMove
 * @param {string} windowId             The id or name of the window to drag
 * @param {CBWindowResult} callback     A callback which is called when the drag is completed
 */

/**
 * Closes the window.
 * 
 * @callback close
 * @param {string} windowId             The id or name of the window to close
 * @param {CBWindowResult} callback     Called after the window is closed
 */

/**
 * Minimizes the window.
 * 
 * @callback minimize
 * @param {string} windowId             The id or name of the window to minimize
 * @param {CBWindowResult} callback     Called after the window is minimized
 */

/**
 * Maximize the window.
 * 
 * * This function will not work if the manifest resizable flag is set to false.
 * * If you would like to "unmaximize" the window after calling "maximize()", you can call window.restore(), to restore the window to the previous size/position.
 * 
 * @callback maximize
 * @param {string} windowId             The id or name of the window to maximize
 * @param {CBWindowResult} callback     Called after the window is maximized
 */

/**
 * Restores a minimized/maximized/hidden window.
 * 
 * @callback restore
 * @param {string} window               The id or name of the window to restore
 * @param {CBWindowResult?} callback    Called after the window is restored
 */

/**
 * A callback function which will be called with a window object as a parameter
 * 
 * @callback CBWindowResult
 * @param {WindowResult} window
 * @returns {void}
 */

/**
 * Use this API to create, interact with and modify your app’s windows.
 * 
 * @typedef {object} WindowsAPI
 * @property {getMainWindow} getMainWindow
 * @property {getCurrentWindow} getCurrentWindow 
 * @property {obtainDeclaredWindow} obtainDeclaredWindow
 * @property {dragMove} dragMove
 * @property {close} close
 * @property {minimize} minimize
 * @property {maximize} maximize
 * @property {restore} restore
 */
"use strict";

},{}],4:[function(require,module,exports){
"use strict";

var _Data = _interopRequireDefault(require("./methods/Data"));

var _overwolf = _interopRequireDefault(require("./docs/overwolf"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // Methods
// Docs
// Setup data


var App = (0, _Data["default"])(window, {
  windows: {}
}); // Load dashboard

_overwolf["default"].windows.obtainDeclaredWindow('Dashboard', function (_ref) {
  var success = _ref.success,
      window = _ref.window; //

  if (success) {
    // Store window
    App.windows[window.name] = window.id; // Restore window

    _overwolf["default"].windows.restore(window.id);
  }
});

},{"./docs/overwolf":1,"./methods/Data":5}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = Data;
/**
 * Create ref to data in the main window for communication between windows
 * 
 * @param {Window} window 
 * @returns {MainData}
 */

function Data(window) {
  var initialState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; // Init app object if doesn't exists

  if (typeof window.app == 'undefined') window.app = initialState; // Return reference

  return window.app;
}
/**
 * @typedef {Object} MainData
 * @property {Object} app
 */

},{}]},{},[4]);
